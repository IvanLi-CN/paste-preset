name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

permissions:
  contents: read

jobs:
  quality:
    runs-on: ubuntu-latest
    env:
      CI: true
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: "1.3.3"

      - name: Install dependencies
        run: bun install

      - name: Run Biome lint
        run: bun run lint

      - name: Run Biome check (lint + format + imports)
        run: bun run check

      - name: Compute effective version
        shell: bash
        run: ./.github/scripts/compute-version.sh

      - name: Build project
        env:
          VITE_APP_VERSION: ${{ env.APP_EFFECTIVE_VERSION }}
        run: bun run build

      - name: Install Playwright browsers (chromium)
        run: bunx playwright install --with-deps chromium

      - name: Run Storybook interaction tests
        run: bun run test-storybook

      - name: Run E2E tests
        run: bun run test:e2e

  release-tag:
    name: Create Tag and Release
    runs-on: ubuntu-latest
    needs: quality
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    permissions:
      contents: write
      pull-requests: read
    outputs:
      app_version: ${{ steps.export_version.outputs.version }}
    steps:
      - name: Checkout (full history)
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine release intent (PR label)
        id: intent
        uses: actions/github-script@v7
        with:
          script: |
            const allowed = new Set([
              "type:patch",
              "type:minor",
              "type:major",
              "type:docs",
              "type:skip",
            ]);
            const bumpMap = {
              "type:patch": "patch",
              "type:minor": "minor",
              "type:major": "major",
              "type:docs": "skip",
              "type:skip": "skip",
            };

            const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
            const sha = context.sha;

            // Find the merged PR associated with this commit.
            // Safer default: if missing or ambiguous, skip creating a release.
            const prsResp = await github.request(
              "GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls",
              {
                owner,
                repo,
                commit_sha: sha,
                mediaType: { previews: ["groot"] },
              },
            );

            const prs = prsResp.data || [];
            if (prs.length !== 1) {
              core.info(
                `Expected exactly one PR for ${sha}, got ${prs.length}. Skipping release.`,
              );
              core.setOutput("release", "false");
              return;
            }

            const pr = prs[0];
            const labels = (pr.labels || [])
              .map((l) => (typeof l === "string" ? l : l.name))
              .filter(Boolean);
            const typeLabels = labels.filter((n) => n.startsWith("type:"));
            const invalid = typeLabels.filter((l) => !allowed.has(l));
            if (invalid.length > 0) {
              core.setFailed(
                `Invalid type:* label(s) on PR #${pr.number}: ${invalid.join(", ")}`,
              );
              return;
            }
            if (typeLabels.length !== 1) {
              core.setFailed(
                `PR #${pr.number} must have exactly one type:* label (${Array.from(allowed).join(", ")}). Found: ${
                  typeLabels.length
                } (${typeLabels.join(", ") || "none"})`,
              );
              return;
            }

            const type = typeLabels[0];
            const bump = bumpMap[type];

            core.setOutput("pr_number", String(pr.number));
            core.setOutput("type_label", type);

            if (bump === "skip") {
              core.info(`PR #${pr.number}: ${type} -> skip release`);
              core.setOutput("release", "false");
              return;
            }

            core.info(`PR #${pr.number}: ${type} -> release bump=${bump}`);
            core.setOutput("release", "true");
            core.setOutput("bump", bump);

      - name: Compute effective version
        if: steps.intent.outputs.release == 'true'
        shell: bash
        run: ./.github/scripts/compute-version.sh
        env:
          APP_VERSION_BUMP: ${{ steps.intent.outputs.bump }}

      - name: Export effective version
        id: export_version
        if: steps.intent.outputs.release == 'true'
        shell: bash
        run: |
          echo "version=${APP_EFFECTIVE_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Configure Git user
        if: steps.intent.outputs.release == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Create and push tag (if missing)
        id: tag
        if: steps.intent.outputs.release == 'true'
        shell: bash
        run: |
          set -euo pipefail
          tag="v${APP_EFFECTIVE_VERSION}"
          echo "target tag: $tag"
          if git rev-parse -q --verify "refs/tags/${tag}" >/dev/null; then
            echo "tag_exists=true" >> "$GITHUB_OUTPUT"
            echo "Tag ${tag} already exists. Skipping push."
          else
            git tag -a "${tag}" -m "${tag}"
            git push origin "${tag}"
            echo "tag_exists=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Create GitHub Release
        if: steps.intent.outputs.release == 'true'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ env.APP_EFFECTIVE_VERSION }}
          name: v${{ env.APP_EFFECTIVE_VERSION }}
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
